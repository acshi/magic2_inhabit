diff --git a/config/proc-robot-gen.config b/config/proc-robot-gen.config
index d712928..dbdb2e3 100644
--- a/config/proc-robot-gen.config
+++ b/config/proc-robot-gen.config
@@ -84,9 +84,9 @@ LoggingButton : procGroupLogging {
 // RobotDrive : procGroupControl {
 //     cmd = "robot-drive --id $ROBOT_ID";
 // }
-// DriveToWaypoint : procGroupControl {
-//     cmd = "drive-to-waypoint"
-// }
+DriveToWaypoint : procGroupControl {
+    cmd = "drive-to-waypoint"
+}
 RobotStatus : procGroupControl {
     cmd = "robot-status";
 }
diff --git a/magic2 b/magic2
--- a/magic2
+++ b/magic2
@@ -1 +1 @@
-Subproject commit cbf64783f9984d1dd7bc679f73aac40bc8e72d4c
+Subproject commit cbf64783f9984d1dd7bc679f73aac40bc8e72d4c-dirty
diff --git a/src/acshi_common/lcm_handle_async.h b/src/acshi_common/lcm_handle_async.h
index 458870d..c1bc8b6 100644
--- a/src/acshi_common/lcm_handle_async.h
+++ b/src/acshi_common/lcm_handle_async.h
@@ -1,9 +1,6 @@
-#ifndef LCM_HANDLE_ASYNC_H
-#define LCM_HANDLE_ASYNC_H
+#pragma once
 
 #include <lcm/lcm.h>
 
 // Based on https://github.com/lcm-proj/lcm/blob/master/examples/c/listener-async.c#L59
 void lcm_handle_async(lcm_t *lcm);
-
-#endif
diff --git a/src/drive_to_waypoint/drive_to_waypoint.c b/src/drive_to_waypoint/drive_to_waypoint.c
index ddb1453..7cd9b6e 100644
--- a/src/drive_to_waypoint/drive_to_waypoint.c
+++ b/src/drive_to_waypoint/drive_to_waypoint.c
@@ -1,33 +1,7 @@
-#include <unistd.h>
-#include <stdio.h>
-#include <inttypes.h>
-#include <math.h>
-#include <sys/select.h>
-
-#include "common/doubles.h"
-#include "common/time_util.h"
-#include "common/math_util.h"
-#include "lcm/lcm.h"
-#include "lcmtypes/diff_drive_t.h"
-#include "lcmtypes/pose_t.h"
-#include "lcmtypes/robot_map_data_t.h"
-#include "lcmtypes/waypoint_cmd_t.h"
-#include "lcmtypes/lcmdoubles_t.h"
-#include "acshi_common/lcm_handle_async.h"
-
-#define HEADING_THRESH (4*M_PI/180.0)
-
-typedef struct {
-    lcm_t *lcm;
-    pose_t *last_pose;
-    robot_map_data_t *last_map_data;
-    waypoint_cmd_t *last_cmd;
-
-    double xyt[3];
-    float achievement_dist;
-} drive_to_wp_state_t;
-
-#define CONTROL_UPDATE_MS 15
+#include "drive_to_wp_state.h"
+#include "gui.h"
+#include "common/gridmap.h"
+#include "common/gridmap_util.h"
 
 double dist_to_dest(drive_to_wp_state_t *state) {
     double diff_x = state->last_cmd->xyt[0] - state->xyt[0];
@@ -73,6 +47,10 @@ void receive_robot_map_data(const lcm_recv_buf_t *rbuf, const char *channel,
         robot_map_data_t_destroy(state->last_map_data);
     }
     state->last_map_data = robot_map_data_t_copy(msg);
+    if (state->last_grid_map) {
+        grid_map_t_destroy(state->last_grid_map);
+    }
+    state->last_grid_map = gridmap_decode_and_copy(&msg->gridmap);
 }
 
 void receive_waypoint_cmd(const lcm_recv_buf_t *rbuf, const char *channel,
@@ -88,7 +66,8 @@ void receive_waypoint_cmd(const lcm_recv_buf_t *rbuf, const char *channel,
     state->last_cmd = waypoint_cmd_t_copy(msg);
 }
 
-double constrain(double val, double min_val, double max_val) {
+double constrain(double val, double min_val, double max_val)
+{
     if (val < min_val) {
         return min_val;
     } else if (val > max_val) {
@@ -97,8 +76,130 @@ double constrain(double val, double min_val, double max_val) {
     return val;
 }
 
+static void rasterize_poly_line(int *buff_x0, int *buff_x1, int startX, int startY, int endX, int endY) {
+    // Bresenham's Line Drawing, as applied to rasterizing a convex polygon
+	int cx = startX;
+	int cy = startY;
+
+	int dx = abs(endX - startX);
+	int dy = abs(endY - startY);
+
+	int sx = startX < endX ? 1 : -1;
+	int sy = startY < endY ? 1 : -1;
+
+	int err = dx - dy;
+
+	for (int n = 0; n < 1000; n++) {
+        if (sx < 0) {
+            buff_x0[cy] = cx;
+        } else if (sx > 0) {
+            buff_x1[cy] = cx;
+        } else {
+            if (buff_x0[cy] == -1) {
+                buff_x0[cy] = cx;
+            } else {
+                buff_x0[cy] = min(buff_x0[cy], cx);
+            }
+            if (buff_x1[cy] == -1) {
+                buff_x1[cy] = cx;
+            } else {
+                buff_x1[cy] = max(buff_x0[cy], cx);
+            }
+        }
+
+		if ((cx == endX) && (cy == endY)) {
+			return;
+		}
+		int e2 = 2 * err;
+		if (e2 > -dy) {
+			err = err - dy;
+			cx = cx + sx;
+		}
+		if (e2 < dx) {
+			err = err + dx;
+			cy = cy + sy;
+		}
+	}
+}
+
+bool obstacle_ahead(drive_to_wp_state_t *state, double forward_dist, double left_dist, double right_dist) {
+    grid_map_t *gm = state->last_grid_map;
+    if (!gm) {
+        return true;
+    }
+
+    double cos_theta = cos(state->xyt[2]);
+    double sin_theta = sin(state->xyt[2]);
+
+    double xs[4];
+    double ys[4];
+
+    xs[0] = state->xyt[0] - left_dist * sin_theta;
+    ys[0] = state->xyt[1] - left_dist * cos_theta;
+
+    xs[1] = state->xyt[0] - left_dist * sin_theta + forward_dist * cos_theta;
+    ys[1] = state->xyt[1] - left_dist * cos_theta + forward_dist * sin_theta;
+
+    xs[2] = state->xyt[0] + right_dist * sin_theta + forward_dist * cos_theta;
+    ys[2] = state->xyt[1] + right_dist * cos_theta + forward_dist * sin_theta;
+
+    xs[3] = state->xyt[0] + right_dist * sin_theta;
+    ys[3] = state->xyt[1] + right_dist * cos_theta;
+
+    int ixs[4];
+    int iys[4];
+    int minIY = -1;
+    int maxIY = -1;
+    for (int i = 0; i < 4; i++) {
+        ixs[i] = gridmap_get_index_x(gm, xs[i]);
+        iys[i] = gridmap_get_index_y(gm, ys[i]);
+        if (minIY == -1 || iys[i] < minIY) {
+            minIY = iys[i];
+        }
+        if (maxIY == -1 || iys[i] > maxIY) {
+            maxIY = iys[i];
+        }
+    }
+
+    // rectangle rasterization: https://stackoverflow.com/questions/10061146/how-to-rasterize-rotated-rectangle-in-2d-by-setpixel
+    int buff_x0[gm->height];
+    int buff_x1[gm->height];
+    for (int i = 0; i < gm->height; i++) {
+        buff_x0[i] = -1;
+        buff_x1[i] = -1;
+    }
+
+    rasterize_poly_line(buff_x0, buff_x1, ixs[0], iys[0], ixs[1], iys[1]);
+    rasterize_poly_line(buff_x0, buff_x1, ixs[1], iys[1], ixs[2], iys[2]);
+    rasterize_poly_line(buff_x0, buff_x1, ixs[2], iys[2], ixs[3], iys[3]);
+    rasterize_poly_line(buff_x0, buff_x1, ixs[3], iys[3], ixs[0], iys[0]);
+
+    for (int y = minIY; y <= maxIY; y++) {
+        for (int x = buff_x0[y]; x <= buff_x1[y]; x++) {
+            if (gm->data[y * gm->width + x] != GRID_VAL_TRAVERSABLE) {
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
 void update_control(drive_to_wp_state_t *state)
 {
+    state->stopped_for_obstacle = obstacle_ahead(state, OBS_FORWARD_DIST, OBS_SIDE_DIST, OBS_SIDE_DIST);
+    if (state->stopped_for_obstacle) {
+        diff_drive_t motor_cmd = {
+            .utime = utime_now(),
+            .left = 0,
+            .left_enabled = false,
+            .right = 0,
+            .right_enabled = false
+        };
+        diff_drive_t_publish(state->lcm, "DIFF_DRIVE", &motor_cmd);
+        return;
+    }
+
     if (!state->last_cmd) {
         return;
     }
@@ -153,10 +254,13 @@ int main(int argc, char **argv)
     robot_map_data_t_subscribe(state->lcm, "ROBOT_MAP_DATA", receive_robot_map_data, state);
     waypoint_cmd_t_subscribe(state->lcm, "WAYPOINT_CMD", receive_waypoint_cmd, state);
 
+    gui_init(state);
+
     while (1) {
         lcm_handle_async(state->lcm);
 
         update_control(state);
+        render_gui(state);
 
         nanosleep(&(struct timespec){0, (CONTROL_UPDATE_MS * 1e6)}, NULL);
     }
diff --git a/src/drive_to_waypoint/meson.build b/src/drive_to_waypoint/meson.build
index 0707317..776e323 100644
--- a/src/drive_to_waypoint/meson.build
+++ b/src/drive_to_waypoint/meson.build
@@ -1,7 +1,7 @@
 executable('drive-to-waypoint',
-           ['drive_to_waypoint.c'],
-           c_args: '-Wfloat-conversion',
-           dependencies : [inhabit_lcmtype_dep, acshi_common_dep, lcm_dep, magic_lcmtype_dep, math_dep, april_common_dep, magic_common_dep],
+           ['drive_to_waypoint.c', 'gui.c'],
+           c_args: ['-Wfloat-conversion', '-Werror'],
+           dependencies : [inhabit_lcmtype_dep, acshi_common_dep, lcm_dep, magic_lcmtype_dep, math_dep, april_common_dep, magic_common_dep, vx_dep],
            include_directories : src_inc,
            install : true,
            install_dir : bin_dir)
