
alarm {
    batteryVoltage = 25.9;     // in volts
    startupInhibitTime = 15.0; // inhibit alarms for this many seconds after startup.
    repeatInhibitTime = 8.0;   // don't repeat alarms faster than this (per event)
    maxAlarms = 5; // don't alarm more than this many times (per event)
    //espeak_args = "english:p90:a200";

    // integrate rates over what period? (seconds)
    // (larger values provide more "slush")
    lcm_rates_period = 6.0;

    // min/max rates for LCM channels. (nominal rates in comments for reference)
    lcm_rates {
        //HOKUYO_LIDAR = [ 30 50 ];    // 40
        VELODYNE_DATA = [ 720 780 ];   // 753
        POSE = [ 50 110 ];             // 100
        ROBOT_MAP_DATA = [ 3 7 ];      // 5
        //DWM_RANGE = [ 1 80 ];        // 60
        //IMAGE = [ 3 6 ];             // 5
    }

    ignore_on_estop = [ "HOOP_SKIRT" ];
}

robot_drive {
    repulsive_distance = 1.0;
    collision_distance = 0.2;
    repulsive_strength = 2.0; // rel to goal attraction
    attractive_distance = 0.25; // switch to parabolic
    max_speed = 1.0; // pwm
    st_gain = 0.8;  // nom speed to goal
    trn_gain = 0.8; // mapping of degrees force error to pwm
    trn_max = 0.6; // max turn pwm
    turn_discount = 0.5; //max forward speed is reduced
}

robot {
    geometry {
        width = 0.559; // meters
    }
}

collision-avoidance {
    min-side-distance = 0.2;
    min-forward-distance = 0.8;
    min-forward-per-mps = 0.6; // mps = meters per second
}

imu {
    gyro2rad = 0.000266316;   // +/- 500 deg/s range
    acc2g = 0.00012207;       // +/- 4 g range

    kp = 0.001;
    ki = 0.0001;
    accel_nsamples = 20;
    gyro_nsamples = 50;
    min_covariance = 1e-6;
    process_covariance = 5e-7;
}
